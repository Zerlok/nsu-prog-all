package ru.nsu.ccfit.g13202.troshnev.tetris.kernel;

import ru.nsu.ccfit.g13202.troshnev.tetris.figures.Figure;

import javax.swing.*;
import java.awt.*;

/**
 * Created by zerlok on 4/29/15.
 */
public class Field extends JPanel {
    private int fieldColumnsNum;
    private int fieldRowsNum;
    private Block[][] fieldBlocks;

    public Field(int w, int h) {
        fieldColumnsNum = w;
        fieldRowsNum = h;
        fieldBlocks = new Block[fieldRowsNum][fieldColumnsNum];
    }

    public void addBlock(int rowNum, int columnNum, Block b) {
        if ((rowNum >= 0)
                && (columnNum >= 0)
                && (rowNum < fieldRowsNum)
                && (columnNum < fieldColumnsNum))
            fieldBlocks[rowNum][columnNum] = b;
    }

    public void saveFigure(Figure figure) {
        Block[] figureBlocks = figure.getBlocks();
        Coordinate[] figureBlocksPositions = figure.getBlocksGlobalPositions();

        for (int i = 0; i < figureBlocks.length; i++)
            addBlock(
                    figureBlocksPositions[i].getCoY(), // rowNum
                    figureBlocksPositions[i].getCoX(), // columnNum
                    figureBlocks[i]
            );
    }

    public boolean hasIntersectionWithFigure(Figure figure) {
//        Cycle throw figure blocks.
        for (Coordinate figureBlockPosition : figure.getBlocksGlobalPositions()) {
            int blockRowNum = figureBlockPosition.getCoY();
            int blockColumnNum = figureBlockPosition.getCoX();

//            Check intersections with field borders and field blocks.
            if ((blockColumnNum < 0)
                    || (blockColumnNum >= fieldColumnsNum)
                    || (blockRowNum >= fieldRowsNum)
                    || ((blockRowNum >= 0)
                        && (fieldBlocks[blockRowNum][blockColumnNum] != null)))
                return true;
        }

        return false;
    }

    public void removeFullRows() {
        int columnNum;
        int rowNum;
        int blocksInRow;

        for (rowNum = 0; rowNum < fieldRowsNum; rowNum++) {
            blocksInRow = 0;
            for (columnNum = 0; columnNum < fieldColumnsNum; columnNum++)
                if (fieldBlocks[rowNum][columnNum] != null)
                    blocksInRow++;

            if (blocksInRow == fieldColumnsNum)
                shiftLinesDownFromRow(rowNum);
        }
    }

    private void shiftLinesDownFromRow(int emptyRowNum) {
        int columnNum;
        int rowNum;

//        Cycle from empty row to top.
        for (rowNum = emptyRowNum; rowNum > 0; rowNum--)
            for (columnNum = 0; columnNum < fieldColumnsNum; columnNum++)
                fieldBlocks[rowNum][columnNum] = fieldBlocks[rowNum - 1][columnNum];

//        Delete top fieldBlocks at 0 rowNum.
        for (columnNum = 0; columnNum < fieldColumnsNum; columnNum++)
            fieldBlocks[0][columnNum] = null;
    }

    public int getFieldColumnsNum() {
        return fieldColumnsNum;
    }

    public int getFieldRowsNum() {
        return fieldRowsNum;
    }

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2d = (Graphics2D) g;

//        Draw the rest fieldBlocks.
        int columnNum;
        int rowNum;

        for(rowNum = 0; rowNum < fieldRowsNum; rowNum++)
            for (columnNum = 0; columnNum < fieldColumnsNum; columnNum++)
                if (fieldBlocks[rowNum][columnNum] != null)
                    fieldBlocks[rowNum][columnNum].draw(rowNum, columnNum, g2d);
    }
}
